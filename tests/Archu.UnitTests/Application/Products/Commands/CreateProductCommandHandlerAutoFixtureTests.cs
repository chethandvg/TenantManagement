using Archu.Application.Products.Commands.CreateProduct;
using Archu.Contracts.Products;
using Archu.Domain.Entities;
using Archu.UnitTests.TestHelpers.Fixtures;
using FluentAssertions;
using Moq;
using Xunit;

namespace Archu.UnitTests.Application.Products.Commands;

/// <summary>
/// Demonstrates using AutoFixture with command handler tests.
/// These tests showcase improved data variability and reduced boilerplate.
/// </summary>
[Trait("Category", "Unit")]
[Trait("Feature", "Products")]
[Trait("Pattern", "AutoFixture")]
public class CreateProductCommandHandlerAutoFixtureTests
{
    [Theory, AutoMoqData]
    public async Task Handle_WithVariousProductData_CreatesProductSuccessfully(
        string productName,
        decimal price,
        Guid userId)
    {
        // Arrange - AutoFixture generates unique data for each test run
        var fixture = new CommandHandlerTestFixture<CreateProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithProductRepositoryForAdd();

        var handler = fixture.CreateHandler();
        var command = new CreateProductCommand(productName, price);

        // Act
        var result = await handler.Handle(command, CancellationToken.None);

        // Assert
        result.Should().NotBeNull();
        result.Name.Should().Be(productName);
        result.Price.Should().Be(price);

        fixture.VerifyProductAdded();
        fixture.VerifySaveChangesCalled();
    }

    [Theory]
    [InlineAutoMoqData("Premium Product", 999.99)]
    [InlineAutoMoqData("Budget Product", 9.99)]
    [InlineAutoMoqData("Standard Product", 49.99)]
    public async Task Handle_WithInlineAndGeneratedData_CreatesProductSuccessfully(
        string productName,
        decimal price,
        Guid userId)
    {
        // Arrange - Combines inline values with AutoFixture-generated userId
        var fixture = new CommandHandlerTestFixture<CreateProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithProductRepositoryForAdd();

        var handler = fixture.CreateHandler();
        var command = new CreateProductCommand(productName, price);

        // Act
        var result = await handler.Handle(command, CancellationToken.None);

        // Assert
        result.Should().NotBeNull();
        result.Name.Should().Be(productName);
        result.Price.Should().Be(price);

        fixture.VerifyProductAdded();
        fixture.VerifySaveChangesCalled();
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithAutoGeneratedCommand_SetsCorrectOwnerId(
        string productName,
        decimal price,
        Guid expectedOwnerId)
    {
        // Arrange
        var fixture = new CommandHandlerTestFixture<CreateProductCommandHandler>()
            .WithAuthenticatedUser(expectedOwnerId)
            .WithProductRepositoryForAdd();

        Product? capturedProduct = null;
        fixture.MockProductRepository
            .Setup(r => r.AddAsync(It.IsAny<Product>(), It.IsAny<CancellationToken>()))
            .Callback<Product, CancellationToken>((p, _) => capturedProduct = p)
            .ReturnsAsync((Product p, CancellationToken _) => p);

        var handler = fixture.CreateHandler();
        var command = new CreateProductCommand(productName, price);

        // Act
        await handler.Handle(command, CancellationToken.None);

        // Assert
        capturedProduct.Should().NotBeNull();
        capturedProduct!.OwnerId.Should().Be(expectedOwnerId);
        capturedProduct.Name.Should().Be(productName);
        capturedProduct.Price.Should().Be(price);
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithAutoGeneratedData_ReturnsProductDtoWithAllProperties(
        string productName,
        decimal price,
        Guid userId,
        Guid productId,
        byte[] rowVersion)
    {
        // Arrange - AutoFixture generates all test data
        var fixture = new CommandHandlerTestFixture<CreateProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithProductRepositoryForAdd();

        fixture.MockProductRepository
            .Setup(r => r.AddAsync(It.IsAny<Product>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((Product p, CancellationToken _) =>
            {
                p.Id = productId;
                p.RowVersion = rowVersion;
                return p;
            });

        var handler = fixture.CreateHandler();
        var command = new CreateProductCommand(productName, price);

        // Act
        var result = await handler.Handle(command, CancellationToken.None);

        // Assert
        result.Id.Should().Be(productId);
        result.Name.Should().Be(productName);
        result.Price.Should().Be(price);
        result.RowVersion.Should().BeEquivalentTo(rowVersion);
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithAutoGeneratedData_LogsInformationWithCorrectDetails(
        string productName,
        decimal price,
        Guid userId,
        Guid productId)
    {
        // Arrange
        var fixture = new CommandHandlerTestFixture<CreateProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithProductRepositoryForAdd();

        fixture.MockProductRepository
            .Setup(r => r.AddAsync(It.IsAny<Product>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((Product p, CancellationToken _) =>
            {
                p.Id = productId;
                return p;
            });

        var handler = fixture.CreateHandler();
        var command = new CreateProductCommand(productName, price);

        // Act
        await handler.Handle(command, CancellationToken.None);

        // Assert - Verify structured logging
        fixture.VerifyStructuredInformationLogged(new Dictionary<string, object?>
        {
            { "UserId", userId },
            { "ProductName", productName }
        });

        fixture.VerifyStructuredInformationLogged(new Dictionary<string, object?>
        {
            { "ProductId", productId },
            { "UserId", userId }
        });
    }

    [Theory, AutoMoqData]
    public void CreateProductCommand_WithAutoGeneratedData_HasValidProperties(
        string name,
        decimal price)
    {
        // Demonstrate how AutoFixture can be used to test value objects and commands
        var command = new CreateProductCommand(name, price);

        command.Name.Should().Be(name);
        command.Price.Should().Be(price);
        command.Name.Should().NotBeNullOrEmpty();
    }

    [Theory, AutoMoqData]
    public void ProductDto_WithAutoGeneratedData_MapsCorrectly(
        Guid id,
        string name,
        decimal price,
        byte[] rowVersion)
    {
        // AutoFixture generates realistic test data
        var dto = new ProductDto
        {
            Id = id,
            Name = name,
            Price = price,
            RowVersion = rowVersion
        };

        dto.Id.Should().Be(id);
        dto.Name.Should().Be(name);
        dto.Price.Should().Be(price);
        dto.RowVersion.Should().BeEquivalentTo(rowVersion);
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithAutoGeneratedCommand_CreatesProduct(
        CreateProductCommand command,
        Guid userId)
    {
        // Arrange - AutoFixture automatically generates the command with realistic data
        var fixture = new CommandHandlerTestFixture<CreateProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithProductRepositoryForAdd();

        var handler = fixture.CreateHandler();

        // Act - Use the auto-generated command directly
        var result = await handler.Handle(command, CancellationToken.None);

        // Assert
        result.Should().NotBeNull();
        result.Name.Should().Be(command.Name);
        result.Price.Should().Be(command.Price);

        // Verify command properties are realistic
        command.Name.Should().StartWith("Product-");
        command.Price.Should().BeInRange(0, 10000);

        fixture.VerifyProductAdded();
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithMultipleAutoGeneratedCommands_CreatesAllProducts(
        CreateProductCommand command1,
        CreateProductCommand command2,
        CreateProductCommand command3,
        Guid userId)
    {
        // Demonstrates AutoFixture generating multiple unique commands
        var commands = new[] { command1, command2, command3 };

        foreach (var command in commands)
        {
            // Arrange
            var fixture = new CommandHandlerTestFixture<CreateProductCommandHandler>()
                .WithAuthenticatedUser(userId)
                .WithProductRepositoryForAdd();

            var handler = fixture.CreateHandler();

            // Act
            var result = await handler.Handle(command, CancellationToken.None);

            // Assert
            result.Should().NotBeNull();
            result.Name.Should().Be(command.Name);
            result.Price.Should().Be(command.Price);
        }

        // Verify all commands have unique names
        var names = commands.Select(c => c.Name).ToArray();
        names.Should().OnlyHaveUniqueItems();
    }

    [Theory, AutoMoqData]
    public async Task Handle_MultipleRandomDataSets_CreatesProductsConsistently(
        string productName1,
        decimal price1,
        string productName2,
        decimal price2,
        Guid userId)
    {
        // Demonstrates AutoFixture generating multiple unique values
        var testData = new[]
        {
            (productName1, price1),
            (productName2, price2)
        };

        foreach (var (name, price) in testData)
        {
            // Arrange
            var fixture = new CommandHandlerTestFixture<CreateProductCommandHandler>()
                .WithAuthenticatedUser(userId)
                .WithProductRepositoryForAdd();

            var handler = fixture.CreateHandler();
            var command = new CreateProductCommand(name, price);

            // Act
            var result = await handler.Handle(command, CancellationToken.None);

            // Assert
            result.Should().NotBeNull();
            result.Name.Should().Be(name);
            result.Price.Should().Be(price);
        }
    }
}
