using Archu.Application.Products.Commands.DeleteProduct;
using Archu.Domain.Entities;
using Archu.UnitTests.TestHelpers.Builders;
using Archu.UnitTests.TestHelpers.Fixtures;
using FluentAssertions;
using Xunit;

namespace Archu.UnitTests.Application.Products.Commands;

/// <summary>
/// Demonstrates AutoFixture usage with DeleteProductCommandHandler.
/// Shows how AutoFixture simplifies test data generation for delete operations.
/// </summary>
[Trait("Category", "Unit")]
[Trait("Feature", "Products")]
[Trait("Pattern", "AutoFixture")]
public class DeleteProductCommandHandlerAutoFixtureTests
{
    [Theory, AutoMoqData]
    public async Task Handle_WithAutoGeneratedData_DeletesProductSuccessfully(
        Guid productId,
        Guid userId)
    {
        // Arrange - AutoFixture generates unique IDs
        var existingProduct = new ProductBuilder()
            .WithId(productId)
            .WithOwnerId(userId)
            .Build();

        var fixture = new CommandHandlerTestFixture<DeleteProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithExistingProduct(existingProduct);

        var handler = fixture.CreateHandler();
        var command = new DeleteProductCommand(productId);

        // Act
        var result = await handler.Handle(command, CancellationToken.None);

        // Assert
        result.Should().NotBeNull();
        result.IsSuccess.Should().BeTrue();

        fixture.VerifyProductDeleted();
        fixture.VerifySaveChangesCalled();
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithNonExistentProductId_ReturnsFailure(
        Guid nonExistentProductId,
        Guid userId)
    {
        // Arrange - AutoFixture generates random product ID
        var fixture = new CommandHandlerTestFixture<DeleteProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithProductNotFound(nonExistentProductId);

        var handler = fixture.CreateHandler();
        var command = new DeleteProductCommand(nonExistentProductId);

        // Act
        var result = await handler.Handle(command, CancellationToken.None);

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Error.Should().Be("Product not found");

        fixture.VerifyWarningLogged($"Product with ID {nonExistentProductId} not found");
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithAutoGeneratedData_LogsCorrectInformation(
        Guid productId,
        Guid userId)
    {
        // Arrange
        var existingProduct = new ProductBuilder()
            .WithId(productId)
            .Build();

        var fixture = new CommandHandlerTestFixture<DeleteProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithExistingProduct(existingProduct);

        var handler = fixture.CreateHandler();
        var command = new DeleteProductCommand(productId);

        // Act
        await handler.Handle(command, CancellationToken.None);

        // Assert - Verify both log messages (handler logs twice)
        fixture.VerifyInformationLogged($"User {userId} deleting product with ID: {productId}");
        fixture.VerifyInformationLogged($"Product with ID {productId} deleted successfully");
    }

    [Theory]
    [InlineAutoMoqData("550e8400-e29b-41d4-a716-446655440000")]
    [InlineAutoMoqData("6ba7b810-9dad-11d1-80b4-00c04fd430c8")]
    [InlineAutoMoqData("7c9e6679-7425-40de-944b-e07fc1f90ae7")]
    public async Task Handle_WithSpecificProductIds_DeletesCorrectly(
        string productIdString,
        Guid userId)
    {
        // Arrange - Combines inline GUIDs with AutoFixture-generated userId
        var productId = Guid.Parse(productIdString);
        var existingProduct = new ProductBuilder()
            .WithId(productId)
            .Build();

        var fixture = new CommandHandlerTestFixture<DeleteProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithExistingProduct(existingProduct);

        var handler = fixture.CreateHandler();
        var command = new DeleteProductCommand(productId);

        // Act
        var result = await handler.Handle(command, CancellationToken.None);

        // Assert
        result.IsSuccess.Should().BeTrue();
        fixture.VerifyProductDeleted();
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithMultipleAutoGeneratedProducts_DeletesAllSuccessfully(
        Guid productId1,
        Guid productId2,
        Guid userId)
    {
        // Demonstrates AutoFixture generating multiple unique IDs
        var productIds = new[] { productId1, productId2 };

        foreach (var productId in productIds)
        {
            // Arrange
            var product = new ProductBuilder()
                .WithId(productId)
                .Build();

            var fixture = new CommandHandlerTestFixture<DeleteProductCommandHandler>()
                .WithAuthenticatedUser(userId)
                .WithExistingProduct(product);

            var handler = fixture.CreateHandler();
            var command = new DeleteProductCommand(productId);

            // Act
            var result = await handler.Handle(command, CancellationToken.None);

            // Assert
            result.IsSuccess.Should().BeTrue();
            fixture.VerifyProductDeleted();
            fixture.VerifySaveChangesCalled();
        }
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithAutoGeneratedCancellationToken_PassesTokenCorrectly(
        Guid productId,
        Guid userId)
    {
        // Arrange
        var cts = new CancellationTokenSource();
        var cancellationToken = cts.Token;

        var existingProduct = new ProductBuilder()
            .WithId(productId)
            .Build();

        var fixture = new CommandHandlerTestFixture<DeleteProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithExistingProduct(existingProduct);

        var handler = fixture.CreateHandler();
        var command = new DeleteProductCommand(productId);

        // Act
        await handler.Handle(command, cancellationToken);

        // Assert - Verify token was passed through
        fixture.VerifyProductFetchedWithToken(productId, cancellationToken);
        fixture.VerifySaveChangesCalledWithToken(cancellationToken);
    }

    [Theory, AutoMoqData]
    public void DeleteProductCommand_WithAutoGeneratedId_HasValidProperties(
        Guid productId)
    {
        // Test command object creation with AutoFixture
        var command = new DeleteProductCommand(productId);

        command.Id.Should().Be(productId);
        command.Id.Should().NotBeEmpty();
    }
}
