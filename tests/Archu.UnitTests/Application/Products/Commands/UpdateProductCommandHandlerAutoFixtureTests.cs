using Archu.Application.Products.Commands.UpdateProduct;
using Archu.Domain.Entities;
using Archu.UnitTests.TestHelpers.Builders;
using Archu.UnitTests.TestHelpers.Fixtures;
using FluentAssertions;
using Xunit;

namespace Archu.UnitTests.Application.Products.Commands;

/// <summary>
/// Demonstrates AutoFixture usage with UpdateProductCommandHandler.
/// Shows how AutoFixture reduces boilerplate while maintaining test clarity.
/// </summary>
[Trait("Category", "Unit")]
[Trait("Feature", "Products")]
[Trait("Pattern", "AutoFixture")]
public class UpdateProductCommandHandlerAutoFixtureTests
{
    [Theory, AutoMoqData]
    public async Task Handle_WithAutoGeneratedData_UpdatesProductSuccessfully(
        string newName,
        decimal newPrice,
        Guid userId)
    {
        // Arrange - AutoFixture generates unique test data
        var existingProduct = new ProductBuilder()
            .WithName("Original Name")
            .WithPrice(50.00m)
            .WithOwnerId(userId)
            .Build();

        var originalRowVersion = existingProduct.RowVersion;

        var fixture = new CommandHandlerTestFixture<UpdateProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithExistingProduct(existingProduct);

        var handler = fixture.CreateHandler();
        var command = new UpdateProductCommand(
            existingProduct.Id,
            newName,
            newPrice,
            originalRowVersion);

        // Act
        var result = await handler.Handle(command, CancellationToken.None);

        // Assert
        result.Should().NotBeNull();
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value!.Name.Should().Be(newName);
        result.Value.Price.Should().Be(newPrice);

        fixture.VerifyProductUpdated();
        fixture.VerifySaveChangesCalled();
    }

    [Theory]
    [InlineAutoMoqData("Updated Premium", 1999.99)]
    [InlineAutoMoqData("Updated Budget", 19.99)]
    [InlineAutoMoqData("Updated Standard", 99.99)]
    public async Task Handle_WithInlineAndGeneratedData_UpdatesCorrectly(
        string newName,
        decimal newPrice,
        Guid userId)
    {
        // Arrange - Combines inline values with AutoFixture-generated data
        var existingProduct = new ProductBuilder()
            .WithOwnerId(userId)
            .Build();

        var fixture = new CommandHandlerTestFixture<UpdateProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithExistingProduct(existingProduct);

        var handler = fixture.CreateHandler();
        var command = new UpdateProductCommand(
            existingProduct.Id,
            newName,
            newPrice,
            existingProduct.RowVersion);

        // Act
        var result = await handler.Handle(command, CancellationToken.None);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value!.Name.Should().Be(newName);
        result.Value.Price.Should().Be(newPrice);
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithAutoGeneratedRowVersion_DetectsConcurrencyConflict(
        string newName,
        decimal newPrice,
        byte[] differentRowVersion,
        Guid userId)
    {
        // Arrange - AutoFixture generates different row version
        var existingProduct = new ProductBuilder()
            .WithRowVersion(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 })
            .Build();

        var fixture = new CommandHandlerTestFixture<UpdateProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithExistingProduct(existingProduct);

        var handler = fixture.CreateHandler();
        var command = new UpdateProductCommand(
            existingProduct.Id,
            newName,
            newPrice,
            differentRowVersion);

        // Act
        var result = await handler.Handle(command, CancellationToken.None);

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Error.Should().Contain("modified by another user");
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithAutoGeneratedData_LogsCorrectInformation(
        string newName,
        decimal newPrice,
        Guid userId)
    {
        // Arrange
        var existingProduct = new ProductBuilder().Build();

        var fixture = new CommandHandlerTestFixture<UpdateProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithExistingProduct(existingProduct);

        var handler = fixture.CreateHandler();
        var command = new UpdateProductCommand(
            existingProduct.Id,
            newName,
            newPrice,
            existingProduct.RowVersion);

        // Act
        await handler.Handle(command, CancellationToken.None);

        // Assert - Verify both log messages (handler logs twice)
        fixture.VerifyInformationLogged($"User {userId} updating product with ID: {existingProduct.Id}");
        fixture.VerifyInformationLogged($"Product with ID {existingProduct.Id} updated successfully");
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithAutoGeneratedProductId_ReturnsNotFoundWhenProductDoesNotExist(
        Guid nonExistentProductId,
        string newName,
        decimal newPrice,
        byte[] rowVersion,
        Guid userId)
    {
        // Arrange - AutoFixture generates all IDs
        var fixture = new CommandHandlerTestFixture<UpdateProductCommandHandler>()
            .WithAuthenticatedUser(userId)
            .WithProductNotFound(nonExistentProductId);

        var handler = fixture.CreateHandler();
        var command = new UpdateProductCommand(
            nonExistentProductId,
            newName,
            newPrice,
            rowVersion);

        // Act
        var result = await handler.Handle(command, CancellationToken.None);

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Error.Should().Be("Product not found");

        fixture.VerifyWarningLogged($"Product with ID {nonExistentProductId} not found");
    }

    [Theory, AutoMoqData]
    public async Task Handle_WithMultipleAutoGeneratedUpdates_ProcessesAllCorrectly(
        string name1,
        decimal price1,
        string name2,
        decimal price2,
        Guid userId)
    {
        // Demonstrates AutoFixture generating multiple unique values
        var updates = new[]
        {
            (name1, price1),
            (name2, price2)
        };

        foreach (var (name, price) in updates)
        {
            // Arrange
            var product = new ProductBuilder().Build();
            var fixture = new CommandHandlerTestFixture<UpdateProductCommandHandler>()
                .WithAuthenticatedUser(userId)
                .WithExistingProduct(product);

            var handler = fixture.CreateHandler();
            var command = new UpdateProductCommand(
                product.Id,
                name,
                price,
                product.RowVersion);

            // Act
            var result = await handler.Handle(command, CancellationToken.None);

            // Assert
            result.IsSuccess.Should().BeTrue();
            result.Value!.Name.Should().Be(name);
            result.Value.Price.Should().Be(price);
        }
    }

    [Theory, AutoMoqData]
    public void UpdateProductCommand_WithAutoGeneratedData_HasValidProperties(
        Guid id,
        string name,
        decimal price,
        byte[] rowVersion)
    {
        // Test command object creation with AutoFixture
        var command = new UpdateProductCommand(id, name, price, rowVersion);

        command.Id.Should().Be(id);
        command.Name.Should().Be(name);
        command.Price.Should().Be(price);
        command.RowVersion.Should().BeEquivalentTo(rowVersion);
    }
}
